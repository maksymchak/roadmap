5.Work with server
- Сеть и обмен данными (HTTP, API, REST API, JSON)
- AJAX (AJAX, XMLHttpRequest)
- Асинхронный JavaScript (Promise, Fetch, Async/await) 

/**************************************** Test *********************************************/
1. Блок (Сеть и обмен данными - HTTP, API, REST API, JSON)
- Что такое Frontend и что такое Backend ?
- Рассказать принцип работы сайтов и приложений с сетью.
- Что такое протокол HTTP, рассказать про него.
- Какие методы HTTP Вы знаете, подробней.
- Что такое API и REST API ?
- Назовите коды состояния.
- Что такое JSON ?
- Используйте методы JSON.parse и JSON.stringify 

2. Блок (AJAX - AJAX, XMLHttpRequest)
- Что такое AJAX, подробно ?
- Что такое XMLHttpRequest, подробно ?
- Создать XMLHttpRequest

3. Блок (Асинхронный JavaScript - Promise, Fetch, Async/await)
- Что такое синхронное и асинхронное программирование ?
- Что такое Promise ?
- Создать Promise и обработать результат.
- Создать цепочку обработки Promise.
- Создать «промисификацию»
- Что такое Fetch ?
- Создать Fetch.
- Что такое Async/await ?
- Используйте Async/await
- Что такое IFrame ?
- Что такое Web Sockets ?


/******************************************************************************************/


/*================================= Сеть и обмен данными ===================================================*/

Общее понятие сетевых взаимодействий
  Любое web приложение или сайт состоит из двух основных частей.

Frontend включает в себя то, что видит пользователь. Находится в вашем браузере. 
  Основу Frontend составляет комплекс HTML, CSS, JavaScript.

Backend часть соответственно находится на сервере. Основная цель – сохранять и 
  обрабатывать данные.


Принцип работы сайтов и приложений с сетью
Работа любого веб сайта это серия сетевых взаимодействий. Клиент (ваш браузер) запрашивает 
  данные у сервера (request). Сервер обрабатывает запрос и отвечает браузеру (response).

Сайты живут на серверах, у которых есть IP-адрес. Пример // IP-адрес — 178.79.181.169
  На сервере запущено много программ. Сайты живут в программе - веб-сервер.
  У них тоже есть номера - порты. 
  – Номер порта веб-сервера по умолчанию — 80.
  – Популярные веб-сервера: Apache HTTP Server, nginx.
  – Пример адреса — // http://htmlacademy.ru:80.

Веб-сервер-коммуналка (обслуживает несколько сайтов)
  – Такие сервера содержат виртуальные хосты.
  – Веб-сервер отдаёт нужный сайт по его названию.

Но как браузер узнаёт адрес? - с помощью системы DNS 
  (система соответствия имен сайтов IP-адресам)
  – Дано: htmlacademy.ru.
  – Надо получить: // 178.79.181.169.
DNS обновляется медленно

Какую службу доставки использует браузер? (чтобы доставить с веб-сервера сайт в наш браузер)
Службы доставки в Сети:
 – Служба доставки — протокол TCP/IP
 – Доставляет HTTP-пакеты

Для SPA (Single Page Application) схема выглядит таким образом:
• браузер выполняет запрос на определенный адрес URL;
• сервер обрабатывает запрос, и отсылает назад браузеру HTML страницу, 
  которая содержит только основные элементы верстки, подключенные стили 
  и JavaScript файлы;
• браузер получает ответ и показывает страницу, однако в таком виде страница 
  является «полупустой» и пользователю обычно бесполезна;
• начинают выполнятся скрипты, которые снова обращаются к серверу и загружают 
  все недостающие данные с помощью технологии AJAX. Загрузка новых данных может 
  происходить «на фоне». Не нужно перезагружать страницу.

Браузерные движки - это библиотека, которая на входе получает html,css и генерирует итоговую
  картинку страницы. Blink — движок браузера Google Chrome


Протокол HTTP
HTTP-запрос - то что наш браузер отправляет на веб-сервер
HTTP-ответ - возвращает

HTTP (англ. HyperText Transfer Protocol – «протокол передачи гипертекста») –
  специальный протокол предназначенный для передачи данных в виде текста.

Для непосредственной передачи данных по сети используется протокол TCP, 
  HTTP работает на его основе и отвечает за «смысловую нагрузку» тех данных, 
  которые пересылаются.

Структура протокола:
• стартовая строка (Starting line) – тип сообщения;
• заголовки (Headers) – параметры сообщения;
• тело сообщения (Message Body) – данные сообщения (обязательно должно 
  отделяться от заголовков пустой строкой).

Стартовая строка запроса (метод, url, версия):
GET /wiki/HTTP HTTP/1.0
Host: ru.wikipedia.org

Стартовая строка ответа (версия, код состояния, комментарий):
HTTP/1.0 200 OK

Методы передачи данных - GET, POST, PUT, DELETE.
Методы HTTP – ключевые слова, которые определяют способ
  взаимодействия с сервером (операцию, которую надо произвести с ресурсом).

GET – запрашивает данные из определенного ресурса. Наиболее популярный способ 
  загрузить html, css, png или другие данные.

HEAD - запрашивает ресурс так же, как и метод GET, но без тела ответа. Применяется 
  для проверки наличия ресурса и чтобы узнать, не изменился ли он с момента последнего 
  обращения.

POST - используется для отправки данных пользователя на определённый ресурс (URL). 
  Передаваемые данные включаются в тело запроса. Используется для загрузки файлов на 
  сервер.

PUT - заменяет текущие содержимое ресурса данными запроса. Метод POST предназначен 
  для «создания» новых сущностей, а метод PUT для «обновления» ранее созданных данных.

OPTIONS - используется для определения параметров соединения с определенным ресурсом 
  или для определения возможностей сервера.

DELETE - удаляет указанные данные. 

Существует не малое количество методов, однако наиболее часто применяют два из них: GET и POST.


API — это интерфейс взаимодействия между программами, а если говорить о WEB, то 
  это интерфейс взаимодействия различных сайтов со сторонними приложениями. Используя 
  API можно значительно расширить функционал взаимодействия с любым сайтом, у которого 
  есть открытый API. 

REST (RESTful) - это общие принципы организации взаимодействия приложения/сайта с 
  сервером посредством протокола HTTP. Интерфейс взаимодействия клиента с сервером, 
  который соответствует этим принципам называется RESTfull интерфейс.

Коды состояния
В ответ на запрос от клиента, сервер отправляет ответ, который содержит, в том числе, и код состояния
  1** Информационные сообщения
  2** Сообщения об успехе
  3** Перенаправление
  4** Клиентские ошибки
  5** Ошибки сервера


JSON формат
{
    "isAvailable": true,
    "list": [
        {
            "name": "1",
            "seo_name": "ukraine",
            "value": "All",
            "count": 43,
            "is_path": 0
        },
        {
            "name": "1-3",
            "value": "Волинь",
            "seo_name": "volinska-oblast",
            "count": 21,
            "is_path": 1
        }
    ]
}

JSON формат - текстовое представление объектов.
Основные методы для работы с JSON в JavaScript – это:
  - JSON.parse – читает объекты из строки в формате JSON.

  - JSON.stringify – превращает объекты в строку в формате 
      JSON, используется, когда нужно из JavaScript передать 
      данные по сети.


JSON.parse(text, [revieverFunction]) – превращает строку в JSON формате в JavaScript 
  сущность (объект, массив, строку).

  const jsonData='{"isAvailable":true, "list":[{"name": "All","count":43}]}';
  const data = JSON.parse(jsonData);
  console.log(data);


JSON.stringify(data, [filter]) – сериализирует любой объект, массив или структуру в JSON формат.

  const data = {
      id: 12,
      name: "john",
      params: [12,15],
      date: new Date(),
      calc: function() { return 12; }
  }
  const result = JSON.stringify(data);
  console.log(result);


/*================================= AJAX ===================================================*/

AJAX (Asynchronous Javascript And Xml) – технология, которая позволяет обращаться к 
  серверу без необходимости перезагрузки текущей страницы.

AJAX работает, используя все те же HTTP запросы (POST, GET, и т.д.) и может обмениваться 
  данными с сервером в различных форматах: текст, HTML, XML, JSON и др.

При этом, AJAX не является частью JavaScript. Технология AJAX, для своей реализации, использует комбинацию:
  - встроенный в браузер объект XMLHttpRequest (для запроса данных с сервера);
  - JavaScript и DOM (для обработки и отображения данных).

Для обмена данными, должен быть создан объект XMLHttpRequest, который является своеобразным посредником между 
  браузером и сервером. С помощью XMLHttpRequest можно отправить запрос на сервер, а также получить ответ в 
  виде различного рода данных.

Этапы отправки и получения данных:
  • событие, которое инициализирует запрос (например, клик);
  • создание XMLHttpRequest объекта;
  • отправка HTTP запроса с помощью XMLHttpRequest объекта;
  • сервер обрабатывает запрос;
  • сервер отправляет ответ;
  • обработка ответа с помощью JavaScript.


XMLHttpRequest – основа AJAX технологии
XMLHttpRequest – встроенный в браузер объект, который позволяет совершать HTTP-запросы к серверу.

Для работы с AJAX запросами, в первую очередь, необходимо создать новый XMLHttpRequest объект.
  const xhr = new XMLHttpRequest();

Для начала необходимо определить тип (метод) HTTP-запроса, его URL (на какой адрес отправить запрос). 
  Настроить все это поможет метод open() .
  
  xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts?userId=1', true);
  //Первый параметр, это тип запроса, как правило это GET или POST.
  //Второй – URL на который необходимо отправить запрос.
  //Третий параметр, определяет каким будет запрос, true – асинхронный, false – синхронный. 

После определения параметров для запроса, можно его отправить. За данное действие отвечает метод send() .
  xhr.send();

Параметры (если они необходимы) для GET запроса, передаются непосредственно в URL запроса. При POST запросе, 
  параметры передаются в теле запроса, а именно – передаются как параметры в метод send().

Рассмотрим следующие свойства объекта xhr: readyState и status . Свойство readyState – содержит 
  текущее состояние XMLHttpRequest объекта.
  Существует 5 состояний:
  • 0 – UNSENT – объект создан, но метод open() ещё не вызван;
  • 1 – OPENED – метод open() был вызван;
  • 2 – HEADERS_RECEIVED – метод send() был вызван;
  • 3 – LOADING – загрузка, начало получение данных от сервера;
  • 4 – DONE – данные полностью получены, операция завершена.

Свойство status – HTTP-код ответа от сервера.
После отправки запроса, ответ от сервера можно получить с помощью свойства responseText – 
  данные с сервера автоматически попадают в это свойство.
Таким образом, необходимо проверить состояние объекта и статус ответа от сервера, если 
  все успешно, то можно обработать данные от сервера.

Для отслеживания успешного выполнения запроса можно использовать два события 
  onreadystatechange или onload .
//onreadystatechange срабатывает каждый раз, когда изменяется состояние 
//Событие onload срабатывает, когда запрос был успешно выполнен.

  const xhr = new XMLHttpRequest();

  xhr.onload = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
          console.log(xhr.responseText);
      }
  };

  xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts?userId=1', true);
  xhr.send();

Для установки HTTP-заголовков существует специальный метод setRequestHeader() . 
  Этот метод вызывается после open() и перед send().

  const url = 'https://jsonplaceholder.typicode.com/posts';
  const data = {
      title: 'John',
      body: Admin,
      userId: 1
  };
  const json = JSON.stringify(data);

  const xhr = new XMLHttpRequest();
  xhr.open("POST", url, true);
  xhr.setRequestHeader('Content-type','application/json; charset=utf-8');
  xhr.onload = function () {
      const response = JSON.parse(xhr.responseText);
      if (xhr.readyState == 4 && xhr.status == "200") {
          console.table(response);
      } else {
          console.error(response);
      }
  };
  xhr.send(json);

Для обработки ошибок можно использовать событие onerror.
  xhr.onerror = function() {
    console.log('Error!');
  };


/*================================= Асинхронный JavaScript - Promise, Fetch, Async/await ===================================================*/

Синхронное программирование - означает, что весь код выполняется построчно и до тех пор, пока 
  предыдущая операция не будет закончена, следующая не будет запущенна. Сам по себе JavaScript 
  однопоточный, то есть в один момент времени может выполнятся только одна операция.

Асинхронный подход - означает, что выполнение части кода можно переместить из основного потока 
  выполнения в так называемую очередь выполнения, после того как код в основном потоке выполнится, 
  отложенная часть кода, из очереди, может быть возвращена в основной поток и продолжит выполнение.


Promise – объект, который используется для выполнения асинхронных операций и возвращает результат в 
  виде успешного выполнения или ошибки. Promise используется не только для работы с сервером, в отличии
  от XMLHttpRequest. Идея в том, что в одном месте ждем выполнения какого-нибудь действия и когда оно 
  произойдет - в другом месте мы узнаем что оно произошло и мы получим те переданные данные.

Promise может находится в одном из таких состояний:
  • pending – начальное состояние, ожидание;
  • resolve – операция завершена успешно;
  • reject – операция завершена с ошибкой;
  • settled – выполнено или отклонено, но не находится в состоянии ожидания.

Для создания нового Promise необходимо вызвать его с ключевым словом new. Функция-конструктор, 
  как параметр, принимает функцию, в которою автоматически передаются функции resolve и reject, 
  которые вызываются при успешном выполнении операции или ошибке соответственно.

  const enoughSalary = true;

  const buyNewPhone = new Promise(
      function(resolve, reject) {
          if (enoughSalary) {
              const phone = {
                  brand: 'Samsung',
                  model: 'Galaxy S9',
                  color: 'black'
              };
              resolve(phone);
          } else {
              const reason = new Error('Not enough money.');
              reject(reason);
          }
      }
  );

Последующую обработку данных можно совершить в методах then и catch . Для обработки успешного 
  выполнения используется then, а ошибки – catch. 

В переменную buyNewPhone записывается объект (типа Promise), результат выполнения функции конструктора 
  Promise, после чего, данные переданные в resolve (или reject) автоматически попадают в коллбек функцию 
  метода then (или catch при ошибке).

  const enoughSalary = false;

  const buyNewPhone = new Promise(
    function(resolve, reject) {
        if (enoughSalary) {
            const phone = {
                brand: 'Samsung',
                model: 'Galaxy S9',
                color: 'black'
            };
            resolve(phone);
        } else {
            const reason = new Error('Not enough money.');
            reject(reason);
        }
    }
  );

  buyNewPhone
    .then(function(data) {
        console.log(`I've bought ${data.color} ${data.brand} ${data.model}.`);
    })
    .catch(function(error) {
        console.log(error);
    });

Можно использовать более чем один then, создавая при этом цепочку последовательной обработки 
  информации. Для этого из предыдущего then необходимо вернуть нужную информацию.

  buyNewPhone
      .then(function(data) {
          console.log(`I've bought ${data.color} ${data.brand} ${data.model}.`);
          return `I'm very happy!`;
      })
      .then(function(data) {
          console.log(data);
      })
      .catch(function(error) {
          console.log(error);
      });

Существует понятие «промисификация» , которое обозначает, что асинхронное действие 
  «заворачиваем» в Promise

  const url = 'https://jsonplaceholder.typicode.com/posts?userId=1';
  const makeRequest = new Promise(function(resolve, reject) {
      const xhr = new XMLHttpRequest();
      xhr.open('GET', url, true);

      xhr.onload = function() {
          if (xhr.status === 200) {
              resolve(xhr.response);
          } else {
              reject('Error');
          }
      };

      xhr.send();
  });

  makeRequest
      .then((data) => {
          console.log(data);
      })
      .catch((error) => {
          console.log(error);
      });


//---------------Еще пример с Promise---------------------

const promise = new Promise((resolve, reject) => {
  if(true) {
    resolve('promise completed!');
  } else {
    reject();
  }
});

promise 
  .then(data => console.log(data))
  .catch(() => console.log('error'));
//Аргументы resolve и reject это также ф-ции
//resolve - мы вызываем, когда хотим сказать что наш промис завершился успешно
//reject - мы вызываем, когда получили какую-нибудь ошибку
//then и catch - благодоря этой конструкции мы подписываемся на изминения промисса

Fetch
Глобальный метод fetch позволяет, как и XMLHttpRequest, отправлять асинхронный запрос 
  по сети. Преимуществом fetch является упрощенный синтаксис, он возвращает Promise, 
  позволяет легче конфигурировать запросы.

Метод fetch принимает два параметра, первый, обязательный, URL для запроса, второй, 
  необязательный – настройки запроса. Для отправки GET запроса достаточно указать URL.

  fetch('https://jsonplaceholder.typicode.com/posts?userId=1')
      .then((response) => { //Объект response содержит тело ответа
          return response.json();
      })
      .then((data) => { //во втором then достаем тело
          console.log(data);
      });
//Для того, чтобы достать тело ответа у response есть несколько методов, один из них response.json()
//Кроме .json() есть другие ф-ции для других типов ответа: arrayBuffer(), blob(), text(), formData()

Важно отметить, что в первый then попадает не сам ответ от сервера, а Promise, таким образом 
  в нем мы обрабатываем его, а уже следующий then получит непосредственно ответ от сервера.
  Так как запрос был на получение JSON, ответ обрабатывался с помощью json() , ккроме него, 
  для обработки ответов существует text() и много других методов. Из ответа от сервера можно 
  получить и другую информацию.

Для отправки POST запроса, следует определить второй параметр fetch.

  const options = {
      method: 'post',
      headers: {
          'Content-type': 'application/x-www-form-urlencoded; charset=UTF-8'
      },
      body: 'title=foo&body=bar&userId=1'
  }

  fetch('https://jsonplaceholder.typicode.com/posts', options)
      .then((response) => {
          return response.json();
      })
      .then((data) => {
          console.log('Request succeeded with JSON response', data);
      })
      .catch((error) => {
          console.log('Request failed', error);
      });


Async/await
Конструкция async/await позволяет реализовывать асинхронные функции. Такая функция возвращает Promise.
  Ключевое слово async , написанное перед функцией, определяет, что функция является асинхронной (такая 
  функция возвращает Promise) и позволяет использовать внутри нее оператор await , который приостанавливает 
  выполнение функции, на время получения результата. Приостановленная с помощью await функция, так же должна 
  возвращать Promise. Тоесть в основе async/await лежат те же самые Promise.

Асинхронная функция всегда возвращает promise, даже если мы возвращаем что-то другое. Внутри значение 
  автоматически переобразуеться к promise.

  const getProducts = () => {
      return new Promise((resolve, reject) => {
          setTimeout(() => {
              resolve(['bread', 'water', 'oil']);
          }, 2000);
      });
  };

  const buy = (products) => {
      const msg = `You bought: ${products.length} products.`;
      return Promise.resolve(msg);
  }

  async function order() {
      let products = await getProducts();
      let orderMessage = await buy(products);

      return orderMessage;
  };

  order()
      .then((response) => {
          console.log(response);
      });
  // You bought: 3 products.
// Метод Promise.resolve(value) возвращает Promise выполненый с переданным значением.
Функция order является асинхронной, внутри нее вызываются внешние функции, первая 
  из которых имитирует запрос к серверу с задержкой в две секунды. С помощью ключевого 
  слова await выполнение функции order приостанавливается до момента получения результата 
  от функции getProducts. Далее, после получения результата от getProducts, он передается 
  в следующую функцию buy, ожидание ответа от которой так же приостанавливает выполнение 
  функции order. После выполнения всех внутренних функций, результат order можно обработать 
  через уже известный then, благодаря тому, что функция вернула Promise.

//----------- Пример без async/await и с async/await ---------
const load = () => {
  Promise.resolve(5)
    .then(a => {
      Promise.resolve(10)
        .then(b => console.log(a+b))
    })
}
load();//15

const load2 = async () => {
  const a = await Promise.resolve(5);
  const b = await Promise.resolve(10);
  console.log(a+b)
}
load2();//15


IFrame — это кадр внутри кадра. Это компонент HTML-элемента, который позволяет встраивать 
  документы, видео и интерактивные медиафайлы на страницу. Делая это, вы можете отобразить 
  дополнительную веб-страницу на главной странице.

Веб-сокеты (Web Sockets) — это передовая технология, которая позволяет создавать интерактивное 
  соединение между клиентом (браузером) и сервером для обмена сообщениями в режиме реального времени. 
  Веб-сокеты, в отличие от HTTP, позволяют работать с двунаправленным потоком данных, что делает эту 
  технологию совершенно уникальной.