4. Замыкания (области видимости)  
  - Глобальный объект
  - Замыкания, функции изнутри
  - Управление памятью в JavaScript
  
/**************************************** Test *********************************************/
1. Блок (Глобальный объект)
- Что такое глобальный объект?
- Рассказать порядок инициализации

2. Блок (Замыкания, функции изнутри)
- Что такое лексическое окружение ?
- Что такое Scope ?
- Написать функцию-счётчик и пояснить ее.
- Что такое замыкание, подробнее ?
- Scope для new Function ?
- Как работает интепретатор js ?

3. Блок (Управление памятью в JavaScript)
- Пояснить как происходит управление памятью в JavaScript ?

/******************************************************************************************/


/*================================= Глобальный объект ===================================================*/

Глобальными называют переменные и функции, которые не находятся внутри какой-то функции. 
  То есть, иными словами, если переменная или функция не находятся внутри конструкции function, 
  то они – «глобальные».

В JavaScript все глобальные переменные и функции являются свойствами специального объекта, 
  который называется «глобальный объект» (global object).

В браузере этот объект явно доступен под именем window. 
Присваивая или читая глобальную переменную, мы, фактически, работаем со свойствами window.

  var a = 5; // объявление var создаёт свойство window.a
  alert( window.a ); // 5

Порядок инициализации
  Выполнение скрипта происходит в две фазы:
  1. На первой фазе происходит инициализация, подготовка к запуску.
     Во время инициализации скрипт сканируется на предмет объявления функций 
     вида Function Declaration, а затем – на предмет объявления переменных var.
     Каждое такое объявление добавляется в window.
      Функции, объявленные как Function Declaration, создаются сразу работающими, 
      а переменные – равными undefined

  2. На второй фазе – собственно, выполнение.
     Присваивание (=) значений переменных происходит, когда поток выполнения 
      доходит до соответствующей строчки кода, до этого они undefined.

В коде ниже указано содержание глобального объекта на момент инициализации и далее 
  последовательно по коду:

  // На момент инициализации, до выполнения кода:
  // window = { f: function, a: undefined, g: undefined }

  var a = 5;
  // window = { f: function, a: 5, g: undefined }

  function f(arg) { /*...*/ }
  // window = { f: function, a: 5, g: undefined } без изменений, f обработана ранее

  var g = function(arg) { /*...*/ };
  // window = { f: function, a: 5, g: function }

Конструкции for, if... не влияют на видимость переменных.
Фигурные скобки, которые используются в for, while, if, в отличие 
  от объявлений функции, имеют «декоративный» характер.
Также нет разницы между объявлением в цикле и вне него:
  for (var i = 0; i < 5; i++) { }
  //Идентичный по функциональности код:
  var i;
  for (i = 0; i < 5; i++) { }


/*================================= Замыкания, функции изнутри ===================================================*/

Лексическое окружение
Каждая функция в JS имеет лексическое окружение - LexicalEnviroment (Лексическое окружение).
  Все переменные внутри функции – это свойства этого внутреннего объекта LexicalEnvironment.
  При запуске функция создает объект LexicalEnvironment, записывает туда аргументы, функции и переменные.
  
  function sayHi(name) {
    //До выполнения первой строчки её кода, на стадии инициализации:
    // LexicalEnvironment = { name: 'Вася', phrase: undefined }
    var phrase = "Привет, " + name;
    alert( phrase );
  }

  sayHi('Вася');


Доступ ко внешним переменным. Scope
  Из функции мы можем обратиться не только к локальной переменной, но и к внешней:

  var userName = "Вася";

  function sayHi() {
    alert( userName ); // "Вася"
  }

  Интерпретатор, при доступе к переменной, сначала пытается найти переменную в текущем 
  LexicalEnvironment, а затем, если её нет – ищет во внешнем объекте переменных. В данном 
  случае им является window. Если переменная не найдена в функции – она будет искаться снаружи.
  Значение переменной из внешней области берётся всегда текущее. 

Если обобщить:

1. Каждая функция при создании получает ссылку [[Scope]] на объект с переменными, в 
   контексте которого была создана
2. При запуске функции создаётся новый объект с переменными LexicalEnvironment. Он 
   получает ссылку на внешний объект переменных из [[Scope]]
3. При поиске переменных он осуществляется сначала в текущем объекте переменных, а 
   потом – по этой ссылке
4. После использования объект ЛО сразу же удаляется
5. Объект ЛО не будет удален, если в свойсте [[Scope]] какой-то функции сохранена 
   ссылка на него.


Вложенные функции
Внутри функции можно объявлять не только локальные переменные, но и другие функции.

  function sayHiBye(firstName, lastName) {
    alert( "Привет, " + getFullName() );
    alert( "Пока, " + getFullName() );

    function getFullName() {
      return firstName + " " + lastName;
    }
  }

  sayHiBye("Вася", "Пупкин"); // Привет, Вася Пупкин ; Пока, Вася Пупкин

//Вложенные функции получают [[Scope]] так же, как и глобальные. В нашем случае:
//getFullName.[[Scope]] = объект переменных текущего запуска sayHiBye

Функция-счётчик

  function makeCounter() {
    var currentCount = 1;

    return function() { // (**)
      return currentCount++;
    };
  }

  var counter = makeCounter(); // (*)

  // каждый вызов увеличивает счётчик и возвращает результат
  alert( counter() ); // 1  [[Scope]] -> {currentCount: 1}
  alert( counter() ); // 2  [[Scope]] -> {currentCount: 2}
  alert( counter() ); // 3  [[Scope]] -> {currentCount: 3}
 
  // создать другой счётчик, он будет независим от первого
  var counter2 = makeCounter();
  alert( counter2() ); // 1

При каждом запуске makeCounter создаётся свой объект переменных LexicalEnvironment, 
  со своим свойством currentCount, на который новый счётчик получит ссылку [[Scope]].

/*  Если подробнее описать происходящее:
1. В строке (*) запускается makeCounter(). При этом создаётся LexicalEnvironment для переменных 
   текущего вызова. В функции есть одна переменная var currentCount, которая станет свойством этого 
   объекта. Она изначально инициализуется в undefined, затем, в процессе выполнения, получит значение 1:
2. В процессе выполнения makeCounter() создаёт функцию в строке (**). При создании эта функция получает 
   внутреннее свойство [[Scope]] со ссылкой на текущий LexicalEnvironment.
3. Далее вызов makeCounter() завершается и функция (**) возвращается и сохраняется во внешней переменной 
   counter (*).

Итоговым значением, записанным в переменную counter, является функция:
  function() { // [[Scope]] -> {currentCount: 1}
    return currentCount++;
  };

Возвращённая из makeCounter() функция counter помнит (через [[Scope]]) о том, в 
каком окружении была создана.
*/

Замыкание – это функция вместе со всеми внешними переменными, которые ей доступны.
  То есть, замыкание – это функция + внешние переменные.
  Обычно, говоря «замыкание функции», подразумевают не саму эту функцию, 
  а именно внешние переменные.

«Понимать замыкания» в JavaScript означает понимать следующие вещи:
1. Все переменные и параметры функций являются свойствами объекта переменных LexicalEnvironment. 
   Каждый запуск функции создает новый такой объект. На верхнем уровне им является «глобальный объект», 
   в браузере – window
2. При создании функция получает системное свойство [[Scope]], которое ссылается на LexicalEnvironment, 
   в котором она была создана
3. При вызове функции, куда бы её ни передали в коде – она будет искать переменные сначала у себя, а 
   затем во внешних LexicalEnvironment с места своего «рождения».


[[Scope]] для new Function
При создании функции с использованием new Function, её свойство [[Scope]] ссылается не на 
  текущий LexicalEnvironment, а на window. [[Scope]] для new Function - это всегда глобальный объект.
  Такая особеность new Function спасает нас от ошибок(к примеру минификация). Следствие – такие 
  функции не могут использовать замыкание.

  var a = 1;

  function getFunc() {
    var a = 2;

    var func = new Function('', 'alert(a)');

    return func;
  }

  getFunc()(); // 1, из window


ИНТЕПРЕТАТОР
Чтобы лучше понять замыкание, то нужно немного разобраться как работает интепретатор.
  - Интепретатор читает код два разы начиная с глобального объекта.
  - Код функций инициализируется, когда их вызывают.
  - При первом заходе (инициализация) в текущей области видмости (будь-то глобальная 
      или локальная) ищутся все объявления переменных (var) и инструкции объявления 
      функций (Function Declaration).
  - В случае с переменными интепретатор просто подымает их объявления в начало области 
    видимости и присваивает им undefined. Этот процесс назывется hoisting.
  - А функции сделанные при помощи Function Declaration сохряняет как есть.
  - И при втором заходе (выполнение кода) использование объявленных функций возможно 
    до их объявлений.
  - И если мы захотим использовать переменную до ее объявления, то мы получим undefined, 
    а не ошибку.

/*================================= Управление памятью в JavaScript ===================================================*/

УПРАВЛЕНИЯ ПАМЯТЬЮ В JS
 - В Джаваскрипт есть автоматический сборщик мусора (Garbage Collection),
    который использует принцип достижимости (reachability).
 - С примитивами все просто: при присвоении нового значения переменной старое 
    значение сразу же удаляется.
 - Объекты удаляются только в том случаем если они не доступны из корня.
  //Корень - это:
  //1. все глобальные переменные.
  //2. все значения, ссылки на которые содержатся в стеке вызова.
  //И если нету ссылок или цепочки ссылок, которые могут нас привести к объекту из корня,
  //то этот объект будет удален.
Сборщик мусора идёт от корня по ссылкам и запоминает все найденные объекты. По 
  окончанию – он смотрит, какие объекты в нём отсутствуют и удаляет их.